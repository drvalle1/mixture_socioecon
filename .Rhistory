loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nquest=ncol(dat1)
ngroup=15 #maximum number of groups
#number of categories for each questions
nquest.cat=apply(dat1,2,max)
#get initial values
z=sample(1:ngroup,size=ntot,replace=T)
theta=matrix(1/ngroup,nloc,ngroup)
psi=list()
for (i in 1:nquest){
psi[[i]]=matrix(1/nquest.cat[i],ngroup,nquest.cat[i])
}
#priors
gamma1=0.1
alpha=0.1
#useful calculations
log.p.new.group=-sum(log(nquest.cat))
lo=0.000000001
hi=1-lo
#MCMC stuff
ngibbs=1000
store.z=matrix(NA,ngibbs,ntot)
store.theta=matrix(NA,ngibbs,ngroup*nloc)
store.psi=matrix(NA,ngibbs,ngroup*sum(nquest.cat))
reorder1=50
#run gibbs sampler
for (i in 1:ngibbs){
print(i)
#re-order stuff from time to time
if (i%%reorder1==0){
ind=order(apply(theta,2,median),decreasing=T)
theta=theta[,ind]
for (j in 1:nquest) psi[[j]]=psi[[j]][ind,]
znew=z
for (j in 1:ngroup){
cond=z==ind[j]
znew[cond]=j
}
z=znew
}
#sample psi
# for (i in 1:nquest){
#   k=rdirichlet(ngroup-5,rep(1,nquest.cat[i]))
#   psi[[i]]=rbind(psi.true[[i]],k)
# }
psi=sample.psi(z=z,dat1=dat1,nquest.cat=nquest.cat,ngroup=ngroup,
nquest=nquest,alpha=alpha,psi=psi)
#sample v
v=sample.v(z=z,loc.id=loc.id,nloc=nloc,ngroup=ngroup,
gamma1=gamma1)
theta=v.to.theta(v=v,ngroup=ngroup,nloc=nloc)
# tmp=matrix(lo,nloc,ngroup-5)
# theta=cbind(theta.true,tmp)
#to avoid numerical issues with log
log.psi=list()
for (j in 1:nquest){
psi.tmp=psi[[j]]
cond=psi.tmp<lo; psi.tmp[cond]=lo
cond=psi.tmp>hi; psi.tmp[cond]=hi
log.psi[[j]]=log(psi.tmp)
}
cond=theta<lo;   theta[cond]=lo
cond=theta>hi;   theta[cond]=hi
#sample z
log.theta=log(theta)
z=sample.z(log.theta=log.theta,log.psi=log.psi,
ntot=ntot,log.p.new.group=log.p.new.group,z=z,ngroup=ngroup,
loc.id=loc.id,nquest=nquest,dat1=dat1)
#store results
store.z[i,]=z
store.theta[i,]=theta
store.psi[i,]=unlist(psi)
}
theta.estim=theta
psi.estim=psi
zestim=z
library('MCMCpack')
set.seed(7)
setwd('U:\\GIT_models\\mixture_socioecon')
nloc=30
nobs.loc=rpois(nloc,lambda=30)+1
ntot=sum(nobs.loc)
#generate z's
ngroup=7
theta.true=theta=rdirichlet(nloc,rep(0.1,ngroup))
boxplot(theta.true)
res=numeric()
for (i in 1:nloc){
k=rmultinom(1,size=nobs.loc[i],prob=theta[i,])
tmp=rep(1:ngroup,k)
tmp1=data.frame(z=tmp,loc.id=i)
res=rbind(res,tmp1)
}
z.true=res$z
#for multinomial questions
nquestions=18
nmultin.cat=c(rep(2,15),5,3,7)
psi=list()
for (i in 1:nquestions){
psi[[i]]=rdirichlet(ngroup,rep(0.1,nmultin.cat[i]))
}
psi.true=psi
#generate multinomial data
dat=matrix(NA,ntot,nquestions)
for (i in 1:ntot){
tmp1=rep(NA,nquestions)
for (j in 1:nquestions){
tmp=rmultinom(1,size=1,prob=psi[[j]][res$z[i],])
tmp1[j]=which(tmp==1)
}
dat[i,]=tmp1
}
colnames(dat)=paste0('y',1:nquestions)
#combine and export results
fim=cbind(res,dat)
ind=which(colnames(fim)=='z')
fim1=fim[,-ind]
res=data.frame(zestim=zestim,ztrue=z.true)
res1=table(res); res1
#re-order data
ind=numeric()
for (i in 1:ncol(res1)){
tmp=which(res1[,i]==max(res1[,i]))
ind=c(ind,tmp)
}
res1[ind,]
#look at theta
plot(theta.true,theta.estim[,ind])
#look at psi
psi.true1=psi.true[[i]]
psi.estim1=psi.estim[[i]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim1=cbind(psi.estim1,psi.estim[[i]][ind,])
}
plot(psi.true1,psi.estim1)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_socioecon aux functions.R')
source('mixture_socioecon main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
#run gibbs sampler
mod=mixture_socioecon(dat1=dat1,nmax.group=nmax.group,loc.id=loc.id,
gamma1=gamma1,alpha=alpha,ngibbs=ngibbs)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_socioecon aux functions.R')
source('mixture_socioecon main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
#run gibbs sampler
mod=mixture_socioecon(dat1=dat1,nmax.group=nmax.group,loc.id=loc.id,
gamma1=gamma1,alpha=alpha,ngibbs=ngibbs)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_locations aux functions.R')
source('mixture_locations main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_locations aux functions.R')
source('mixture_locations main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_locations aux functions.R')
source('mixture_locations main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
#run gibbs sampler
mod=mixture_locations(dat1=dat1,nmax.group=nmax.group,loc.id=loc.id,
gamma1=gamma1,alpha=alpha,ngibbs=ngibbs)
library('MCMCpack')
set.seed(7)
setwd('U:\\GIT_models\\mixture_socioecon')
nloc=30
nobs.loc=rpois(nloc,lambda=30)+1
ntot=sum(nobs.loc)
#generate z's
ngroup=7
theta.true=theta=rdirichlet(nloc,rep(0.1,ngroup))
boxplot(theta.true)
res=numeric()
for (i in 1:nloc){
k=rmultinom(1,size=nobs.loc[i],prob=theta[i,])
tmp=rep(1:ngroup,k)
tmp1=data.frame(z=tmp,loc.id=i)
res=rbind(res,tmp1)
}
z.true=res$z
#for multinomial questions
nquestions=18
nmultin.cat=c(rep(2,15),5,3,7)
psi=list()
for (i in 1:nquestions){
psi[[i]]=rdirichlet(ngroup,rep(0.1,nmultin.cat[i]))
}
psi.true=psi
#generate multinomial data
dat=matrix(NA,ntot,nquestions)
for (i in 1:ntot){
tmp1=rep(NA,nquestions)
for (j in 1:nquestions){
tmp=rmultinom(1,size=1,prob=psi[[j]][res$z[i],])
tmp1[j]=which(tmp==1)
}
dat[i,]=tmp1
}
colnames(dat)=paste0('y',1:nquestions)
#combine and export results
fim=cbind(res,dat)
ind=which(colnames(fim)=='z')
fim1=fim[,-ind]
res=data.frame(zestim=mod$z[ngibbs,],ztrue=z.true)
res1=table(res); res1
#re-order data
ind=numeric()
for (i in 1:ncol(res1)){
tmp=which(res1[,i]==max(res1[,i]))
ind=c(ind,tmp)
}
res1[ind,]
theta.estim=mod$theta[ngibbs,]
plot(theta.true,theta.estim[,ind])
theta.estim=matrix(mod$theta[ngibbs,],nloc,nmax.group)
plot(theta.true,theta.estim[,ind])
ncat=apply(dat1,2,max)
ncat
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
tmp1=matrix(tmp,nmax.group,ncat[i])
psi.estim1[[i]]=tmp1[ind,]
psi.estim=psi.estim[-ind1]
}
psi.true1=psi.true[[i]]
psi.estim=mod$psi[ngibbs,]
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
tmp1=matrix(tmp,nmax.group,ncat[i])
psi.estim1[[i]]=tmp1[ind,]
psi.estim=psi.estim[-ind1]
}
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
psi.estim1[[i]]=matrix(tmp,nmax.group,ncat[i])
psi.estim=psi.estim[-ind1]
}
psi.estim2=numeric()
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
psi.estim2=psi.estim1[[1]]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
psi.estim2=psi.estim1[[1]]
dim(psi.estim2)
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
dim(psi.true1)
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
psi.true1=psi.true[[i]]
psi.estim=mod$psi[ngibbs,]
#convert to original list
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
psi.estim1[[i]]=matrix(tmp,nmax.group,ncat[i])
psi.estim=psi.estim[-ind1]
}
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
#convert to original list
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
psi.estim1[[i]]=matrix(tmp,nmax.group,ncat[i])
psi.estim=psi.estim[-ind1]
}
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
psi.estim=mod$psi[ngibbs,]
#convert to original list
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
psi.estim1[[i]]=matrix(tmp,nmax.group,ncat[i])
psi.estim=psi.estim[-ind1]
}
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
i=2
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(20)
setwd('U:\\GIT_models\\mixture_socioecon')
source('mixture_locations aux functions.R')
source('mixture_locations main function.R')
dat=read.csv('fake data.csv',as.is=T)
loc.id=dat$loc.id
nloc=max(loc.id)
ntot=nrow(dat)
ind=grep('y',colnames(dat))
dat1=data.matrix(dat[,ind])
nmax.group=15 #maximum number of groups
#priors
gamma1=0.1
alpha=0.1
#number of iterations
ngibbs=1000
#run gibbs sampler
mod=mixture_locations(dat1=dat1,nmax.group=nmax.group,loc.id=loc.id,
gamma1=gamma1,alpha=alpha,ngibbs=ngibbs)
library('MCMCpack')
set.seed(7)
setwd('U:\\GIT_models\\mixture_socioecon')
nloc=30
nobs.loc=rpois(nloc,lambda=30)+1
ntot=sum(nobs.loc)
#generate z's
ngroup=7
theta.true=theta=rdirichlet(nloc,rep(0.1,ngroup))
boxplot(theta.true)
res=numeric()
for (i in 1:nloc){
k=rmultinom(1,size=nobs.loc[i],prob=theta[i,])
tmp=rep(1:ngroup,k)
tmp1=data.frame(z=tmp,loc.id=i)
res=rbind(res,tmp1)
}
z.true=res$z
#for multinomial questions
nquestions=18
nmultin.cat=c(rep(2,15),5,3,7)
psi=list()
for (i in 1:nquestions){
psi[[i]]=rdirichlet(ngroup,rep(0.1,nmultin.cat[i]))
}
psi.true=psi
#generate multinomial data
dat=matrix(NA,ntot,nquestions)
for (i in 1:ntot){
tmp1=rep(NA,nquestions)
for (j in 1:nquestions){
tmp=rmultinom(1,size=1,prob=psi[[j]][res$z[i],])
tmp1[j]=which(tmp==1)
}
dat[i,]=tmp1
}
colnames(dat)=paste0('y',1:nquestions)
#combine and export results
fim=cbind(res,dat)
ind=which(colnames(fim)=='z')
fim1=fim[,-ind]
#look at z's
res=data.frame(zestim=mod$z[ngibbs,],ztrue=z.true)
res1=table(res); res1
#re-order data
ind=numeric()
for (i in 1:ncol(res1)){
tmp=which(res1[,i]==max(res1[,i]))
ind=c(ind,tmp)
}
res1[ind,]
#look at theta
theta.estim=matrix(mod$theta[ngibbs,],nloc,nmax.group)
plot(theta.true,theta.estim[,ind])
psi.estim=mod$psi[ngibbs,]
ncat=apply(dat1,2,max)
ind.aux=1:length(psi.estim)
nquest=ncol(dat1)
psi.estim1=list()
for (i in 1:nquest){
ind1=1:(nmax.group*ncat[i])
tmp=psi.estim[ind1]
psi.estim1[[i]]=matrix(tmp,nmax.group,ncat[i])
psi.estim=psi.estim[-ind1]
}
psi.true1=psi.true[[1]]
psi.estim2=psi.estim1[[1]][ind,]
for (i in 2:nquest){
psi.true1=cbind(psi.true1,psi.true[[i]])
psi.estim2=cbind(psi.estim2,psi.estim1[[i]][ind,])
}
plot(psi.true1,psi.estim2)
